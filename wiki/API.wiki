#summary jQuery Stream 1.1 API Reference
#labels Featured
=API Reference=
<wiki:toc max_depth="3" />

== jQuery.stream ==
The facade of Stream.

===jQuery.stream()===
{{{Stream jQuery.stream()}}}

Returns the first Stream in the document.

===jQuery.stream(url)===
{{{Stream jQuery.stream(String url)}}}

Returns the Stream to which the specified url or alias is mapped.

===jQuery.stream(url, options)===
{{{Stream jQuery.stream(String url, Map options)}}}

Creates a Stream connection (a long-held HTTP request or a !WebSocket connection) allowing a server to push data to a client only if the Stream to which the given url is mapped doesn't exist or does exist and is closed.

*url* - Specifies the URL to which to connect. If it starts with !WebSocket protocol such as ws: or wss:, the stream simply behaves as a wrapper for !WebSocket without fallback. If it starts with HTTP protocol such as http: or https:, the stream performs HTTP streaming. Otherwise, the stream wraps !WebSocket or performs HTTP Streaming according to whether browser support !WebSocket or not. If browser support !WebSocket but server does not, the stream performs HTTP Streaming using the same url after failing try to open !WebSocket connection.

*options* - Configures the Stream connection.

 <b>alias</b> <font size="1">(added in 1.1)</font> - An alias of the url. When retrieving the stream instance by the url, you can use it instead of the lengthy url.

 <b>close</b> - A function or an array of functions to be called if the stream closes. Each function receives a event named {{{close}}} which is based on {{{jQuery.Event}}} and {{{CloseEvent}}} interface and the stream instance as the arguments.

 <b>context</b> - The value to be passed as {{{this}}} to the callback when the event is triggered.

 <b>converters</b> - A map of data-type/data-converter pairs. data-converter takes one argument which is a raw data and returns a transformed data. The default is {{{{text: window.String, json: $.parseJSON, xml: $.parseXML}}}}, {{{jQuery.parseJSON}}} is in 1.4.1 and {{{jQuery.parseXML}}} is in 1.5.

 <b>dataType</b> - The type of data that a server push to a client. The handled data is passed as the {{{data}}} attribute of message event. The supported types are {{{text}}}, {{{json}}} and {{{xml}}}. the default is {{{text}}} itself.

 <b>error</b> - A function or an array of functions to be called if an error is detected. Each function receives a simple event named {{{error}}} which is based on {{{jQuery.Event}}} and the stream instance as the arguments. The usage of this option isn't recommended because {{{onerror}}} attribute have been excluded from {{{WebSocket}}} interface recently.

 <b>iframe</b> <font size="1">(added in 1.1)</font> - Options for iframe transport.

 <b>message</b> - A function or an array of functions to be called if the stream receives a data. Each function receives a event named {{{message}}} which is based on {{{jQuery.Event}}} and {{{MessageEvent}}} interface and the stream instance as the arguments. The event has the data attribute which is sent by the server and is converted according to {{{dataType}}}.

 <b>open</b> - A function or an array of functions to be called if the stream opens. Each function receives a simple event named {{{open}}} which is based on {{{jQuery.Event}}} and the stream instance as the arguments.

 <b>reconnect</b> - Whether to automatically reconnect when connection closed. This is set to {{{true}}} by default for continuous stream.

 <b>throbber</b> - Only for Webkit-based browsers such as Chrome and Safari. This option is to remove 'Throbber of doom' which is spinning loading indicator to show the user that a request is performing. The throbber doesn't be removed only when a Stream is created before all the requests such as image, script, iframe and ajax have finished loading, because a streaming connection is HTTP persistent connection. The following strategies are available:
  lazy - After the window's load event fires and some {{{delay}}}, it opens a Stream connection. The default setting for lazy is {{{{type: "lazy", delay: 50}}}} or simply {{{"lazy"}}}. It is suitable for typical use, unless the page contains many resources so the time taken for loading is very long. This is default.<br/>
  reconnect - Regardless of the window's load event, it opens a Stream connection immediately and closes it when the window's load event fires. Likewise after some {{{delay}}}, it opens a Stream connection again. The default setting for reconnect is {{{{type: "reconnect", delay: 50}}}} or simply {{{"reconnect"}}}. The request which opens a Stream is used twice, but you can provide seamless Stream for the user navigating pages.

 Since both of the above strategy use the window's load event handler, a logic creating a Stream (i.e {{{jQuery.stream("/stream")}}}) must not be located there in order to work this properly.
  * iOS Safari and Android Chrome are currently unsupported.
  * The load event of window doesn't consider ajax request, so when the event fires, incompleted Ajax request can get the throbber to keep spinning.

 <b>ws</b> <font size="1">(added in 1.1)</font> - Options for !WebSocket.
  protocols - An argument to be used to create !WebSocket instance.<br/>
  fallback - If it fails to establish !WebSocket connection, this value will be used to open HTTP connection as url.

 <b>xdr</b> <font size="1">(added in 1.1)</font> - Options for XDomainRequest transport.

 <b>xhr</b> <font size="1">(added in 1.1)</font> - Options for XMLHttpRequest transport.


*Example:* Stream wrapping a !WebSocket instance. If browser doesn't implement !WebSocket, nothing happens.
{{{
$.stream("ws://example.com/stream", {});
}}}

*Example:* Stream performing HTTP Streaming.
{{{
$.stream("http://example.com/stream", {});
}}}

*Example:* If browser and server support !WebSocket, stream will wrap a !WebSocket instance whose url is {{{ws://example.com/stream}}}. Otherwise, stream will perform HTTP Streaming whose url is {{{http://example.com/stream}}}.
{{{
$.stream("/stream", {});
}}}

*Example:* If browser and server support !WebSocket, stream will wrap a !WebSocket instance whose url is {{{ws://example.com/stream-websocket}}} and protocols is {{{chat}}}. Otherwise, stream will perform HTTP Streaming whose url is {{{http://example.com/stream-http}}}.
{{{
$.stream("/stream-websocket", {
    ws: {protocols: "chat", fallback: "/stream-http"}
});
}}}

*Example:* Stream dispatching server-sent events into jQuery's event system.
{{{
$.stream("/event-stream", {
    dataType: "json",
    message: function(event) {
        $.event.trigger(event.data.name, event.data.data);
    }
});
}}}

*Example:* Adding custom converter
{{{
$.stream("/csv-stream", {
    dataType: "csv",
    converters: {
        "csv" : function(data) {
            return data.split(",");
        }
    }
});
}}}

*Example:* Introducing {{{this}}} to the callbacks.
{{{
$.stream("/notice", {
    dataType: "xml",
    context: $("#notice")[0],
    message: function(event, stream) {
        $("<p class='message'>" + event.data.message + "</p>").prependTo(this);
    }
});
}}}

*Example:* Disposable stream.
{{{
$.stream("/countdown.jsp", {
    reconnect: false,
    message: function(event, stream) {
        $("<p>" + event.data + " from " + stream.url + "</p>").appendTo("#panel");
    }
});
}}}

*Example:* Stopping the throbber using reconnect strategy with 100ms delay.
{{{
$.stream("/test.action", {
    throbber: {type: "reconnect", delay: 100}
});
}}}

*Example:* Stream with all callbacks.
{{{
$.stream("/chat", {
    dataType: "json",
    context: $("#content")[0],
    open: function(event, stream) {
        $("#editor").removeAttr("disabled").focus();
        stream.send({username: chat.username, message: "Hello"});
    },
    message: function(event, stream) {
        $("<p />").addClass("message").text(event.data.message).appendTo(this);
    },
    close: function() {
        $("<p />").addClass("message").text("Close").appendTo(this);
        $("#editor").attr("disabled", "disabled");
    }
});
}}}

*Example:* Retrieving a stream.
{{{
$.stream("http://example.com/event-stream", {alias: "event", dataType: "json"});

// If that stream is the first stream in the document
$("#message-text").keyup(function(event) {
    if (event.which === 13) {
        $.stream().send({message: this.value});
    }
});

// Using url
$("#notice-button").click(function() {
    $.stream("http://example.com/event-stream").send({ts: new Date().getTime()});
    return false;
});

// Using alias
$("#close").click(function() {
    $.stream("event").close();
});
}}}

===jQuery.stream.version===
{{{String jQuery.stream.version}}}

Contains the version number of jQuery Stream.
 
== jQuery.fn ==
Global Stream event handlers.

===.streamOpen(handler(event, streamEvent, stream))===
{{{jQuery .streamOpen(Function handler)}}}

Registers a handler to be called when the Stream has opend.

*Example:* Sending a message when Stream opens.
{{{
$(document).streamOpen(function(e, event, stream) {
    stream.send("Hello");
});
}}}

*Example:* Focusing the text input box when Stream opens.
{{{
$("#form :text").streamOpen(function() {
    $(this).focus();
});
}}}

===.streamMessage(handler(event, streamEvent, stream))===
{{{jQuery .streamMessage(Function handler)}}}

Registers a handler to be called when the Stream has received a message.

*Example:* Showing a server-sent message whenever Stream receives a message.
{{{
$("#messages").streamMessage(function(e, event) {
    $("<p />").addClass("message").html(event.data.message).appendTo(this);
});
}}}

===.streamError(handler(event, streamEvent, stream))===
{{{jQuery .streamError(Function handler)}}}

Registers a handler to be called when the Stream has detected a error. The usage of this function isn't recommended because {{{onerror}}} attribute have been excluded from {{{WebSocket}}} interface recently.

===.streamClose(handler(event, streamEvent, stream))===
{{{jQuery .streamClose(Function handler)}}}

Registers a handler to be called when the Stream has closed.

*Example:* Hiding the text input box when Stream whose url is '/test' closes.
{{{
$("#form :button").streamClose(function(e, event, stream) {
    if (stream.url === "/test") {
        $(this).prop("disabled", true);
    }
});
}}}

== Stream Object ==
Stream Object is the main agent that provides Comet Streaming using HTTP and !WebSocket protocol. It is based on [http://dev.w3.org/html5/websockets/ The WebSocket API] which is the ultimate solution to true two-way communication between a client and a server.

it doesn't rely on any specific server-side technology and third-party plugin-in such as ActiveX and Flash, so can be used with any server-side technology supporting asynchronous processing as long as the server meets the requirements. Form details about the requirements, see ServerSideProcessing.

As the Stream constructor is not exposed, use {{{jQuery.stream}}} instead.

Stream supports !WebSocket by simply wrapping its instance and HTTP Streaming by choosing proper transport according to browser and using it to communicate. The paragraphs below describe the streaming over HTTP in more detail.

<h3>Open</h3>

When the constructor is called, it sends a GET request which will be a one-way socket receiving a data from a server in real-time. Since the timestamp parameter ({{{_}}}) is always included in the request URL in order to prevent caching, the server doesn't need to configure it. Depending on the browser, the following transports are used to establish a stream connection.

*Hidden Iframe* - For IE6 and IE7. It's different from the traditional way of fetching response. it polls the response text manually using {{{setTimeout}}} instead of requiring the server to print {{{<script>}}} tag. For this reason, the {{{Content-Type}}} of the response header must be set to 'text/plain', not 'text/html'.

*XDomainRequest* - For IE8 and IE9. See [http://blogs.msdn.com/b/ieinternals/archive/2010/04/06/comet-streaming-in-internet-explorer-with-xmlhttprequest-and-xdomainrequest.aspx COMET Streaming in Internet Explorer] and [http://msdn.microsoft.com/en-us/library/cc288060%28VS.85%29.aspx XDomainRequest Object (MSDN)]. it requires padding to enable streaming and an {{{Access-Control-Allow-Origin}}} response header.

*XMLHttpRequest* - For modern browsers except IE. but in the case of Opera, it polls the response text manually using {{{setTimeout}}}.

The transport is chosen automatically according to the user's browser, and changing it is not allowed.

<h3>Sending data</h3>

Because HTTP Streaming is one-way, it simulates a way of transmitting data of full duplex socket like the !WebSocket by performing POST ajax request. The metadata is a series of the parameters starting with {{{metadata.}}} and included in request body to inform the server of additional data needed by server-side processing. So, following metadata entities are always added to request body.

*metadata.id* - stream identifier.

*metadata.type* - The purpose of request. In most cases, the value is {{{send}}} except a special case such as {{{close}}}.

<h3>Close</h3>

As mentioned above, because HTTP Streaming is one-way, streaming connection remains still open after aborting it in client-side. Therefore, when closing stream jQuery Stream sends a POST request whose metadata type is {{{close}}}.

<h3>Response Requirements</h3>

TODO: This part will be moved to ServerSideProcessing

When responding, the server must meet following requirements.

* Response Header *

 <b>Content-Type</b> - Set to 'text/plain' that is the only one satisfying all streaming transport.

 <b>Access-Control-Allow-Origin</b> - Set to either {{{*}}} or the exact URL of the requesting web page. This header enables response to be shared cross domain, but not cross-domain comet because of obsolete browsers that does not support it. It's just XDomainRequest transport's requirement. For detail information about header, see [http://www.w3.org/TR/access-control/ Cross-Origin Resource Sharing].

* Response Format *

 <b>Id</b> - For further communication, the stream connection id have to be generated and printed at the top of response. It must be unique within the server until the stream closes, so random number (or UUID) is ideal. It must end with a semicolon (;). The id and padding have to be transmitted to the client together. Generated id is managed and used by jQuery Stream.

 <b>Padding</b> - The padding is needed by XMLHttpRequest of !WebKit, XDomainRequest and Hidden iframe transport. One kilobyte is usually enough. it have to end with a semicolon (;). If the browser receives response including id and padding, jQuery Stream handles it and fires open event.

 <b>Message</b> - A message consists of size part and data part. The size part contains message's length and the data part contains message. Each part must end with a semicolon (;). Every time a message arrived, jQuery Stream handles it and fires message event.

*Example:* Chat in Java Servlet 3.0
{{{
package flowersinthesand.example;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;

import javax.servlet.AsyncContext;
import javax.servlet.AsyncEvent;
import javax.servlet.AsyncListener;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.google.gson.Gson;

@WebServlet(urlPatterns = "/chat", asyncSupported = true)
public class ChatServlet extends HttpServlet {

    private static final long serialVersionUID = -2919167206889576860L;
    private Map<String, AsyncContext> contexts = new ConcurrentHashMap<String, AsyncContext>();
    private BlockingQueue<String> messages = new LinkedBlockingQueue<String>();
    private Thread notifier = new Thread(new Runnable() {
        public void run() {
            boolean done = false;
            while (!done) {
                String message = null;
                try {
                    message = messages.take();
                    for (Entry<String, AsyncContext> entry : contexts.entrySet()) {
                        try {
                            sendMessage(entry.getValue().getResponse().getWriter(), message);
                        } catch (IOException e) {
                            contexts.remove(entry.getKey());
                        }
                    }
                } catch (InterruptedException e) {
                    done = true;
                }
            }
        }
    });
    
    private void sendMessage(PrintWriter writer, String message) {
        // Message
        writer.print(message.length());
        writer.print(";");
        writer.print(message);
        writer.print(";");
        writer.flush();
    }

    @Override
    public void init(ServletConfig config) throws ServletException {
        super.init(config);
        notifier.start();
    }

    // GET method is used to open stream
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException,
            IOException {
        response.setCharacterEncoding("utf-8");
        
        // Content-Type header
        response.setContentType("text/plain");
        
        // Access-Control-Allow-Origin header
        response.setHeader("Access-Control-Allow-Origin", "*");

        PrintWriter writer = response.getWriter();
        
        // Id
        final String id = UUID.randomUUID().toString();
        writer.print(id);
        writer.print(';');
        
        // Padding
        for (int i = 0; i < 1024; i++) {
            writer.print(' ');
        }
        writer.print(';');
        writer.flush();
        
        final AsyncContext ac = request.startAsync();
        ac.setTimeout(5 * 60 * 1000);
        ac.addListener(new AsyncListener() {
            public void onComplete(AsyncEvent event) throws IOException {
                contexts.remove(id);
            }

            public void onTimeout(AsyncEvent event) throws IOException {
                contexts.remove(id);
            }

            public void onError(AsyncEvent event) throws IOException {
                contexts.remove(id);
            }

            public void onStartAsync(AsyncEvent event) throws IOException {

            }
        });
        contexts.put(id, ac);
    }

    // POST method is used to handle data sent by user through the stream
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        request.setCharacterEncoding("utf-8");
        
        if ("close".equals(request.getParameter("metadata.type"))) {
            AsyncContext ac = contexts.get(request.getParameter("metadata.id"));
            if (ac != null) {
                ac.complete();
            }
            
            return;
        }

        Map<String, String> data = new LinkedHashMap<String, String>();
        data.put("username", request.getParameter("username"));
        data.put("message", request.getParameter("message"));

        try {
            messages.put(new Gson().toJson(data));
        } catch (Exception e) {
            throw new IOException(e);
        }
    }

    @Override
    public void destroy() {
        messages.clear();
        contexts.clear();
        notifier.interrupt();
    }

}
}}}

===.url===
{{{String url}}}

The Stream URL.

===.options===
{{{Map options}}}

The Stream options.

===.readyState===
{{{Number readyState}}}

The state of the stream. It is the same as !WebSocket's readyState in terms of meaning.

*Example:* Checking the state of the stream.
{{{
$("#stream-state").click(function() {
    switch ($.stream().readyState) {
    case 0:
        alert("CONNECTING");
        break;
    case 1:
        alert("OPEN");
        break;
    case 2:
        alert("CLOSING");
        break;
    case 3:
        alert("CLOSED");
        break;
    }
});
}}}

===.send(data)===
{{{void .send(Object data)}}}

Transmits data through the stream.

*data* - The data to be sent to the server. If not already a string, it is converted to a query string by {{{jQuery.param}}}.

*Example: * Transmitting the mouse position.
{{{
$(document).click(function(event) {
    $.stream().send({x: event.pageX, y: event.pageY});
});
}}}

===.close()===
{{{void .close()}}}

Disconnects the stream.

*Example: * Closing the stream.
{{{
$("#close-stream").click(function() {
    $.stream().close();
});
}}}