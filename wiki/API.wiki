#summary jQuery Stream 1.1.1 API Reference
#labels Featured
=API Reference=
<wiki:toc max_depth="3" />

== jQuery.stream ==
The facade of Stream. 

The mapping between the jQuery version and the jQuery Stream version is:
|| *jQuery Stream version* || *jQuery version* ||
|| 1.x || 1.4||

<h3>[http://code.google.com/p/jquery-stream/issues/list?can=1&q=label%3ATarget-1.1.1 Version 1.1.1]</h3>

Hidden Iframe transport replaces XDomainRequest transport to maintain user's session.
 * jQuery.stream.setup
 * global option
 * openData option
 * enableXDR and rewriteURL option

<h3>[http://code.google.com/p/jquery-stream/issues/list?can=1&q=label%3ATarget-1.1 Version 1.1]</h3>

When migrating from 1.0, you must add the {{{type}}} option having {{{http}}} as a value to stream options.
 * !WebSocket support
 * alias option

<h3>Version 1.0</h3>
 * HTTP Streaming support

===jQuery.stream()===
{{{Stream jQuery.stream()}}}

Returns the first Stream in the document.

===jQuery.stream(url)===
{{{Stream jQuery.stream(String url)}}}

Returns the Stream to which the specified url or alias is mapped.

===jQuery.stream(url, options)===
{{{Stream jQuery.stream(String url, Map options)}}}

Creates a Stream connection (a long-held HTTP request or a !WebSocket connection) allowing a server to push data to a client only if the Stream to which the given url is mapped doesn't exist or does exist and is closed.

*url* - Specifies the URL to which to connect. If it starts with !WebSocket protocol such as ws: or wss:, the stream simply behaves as a wrapper for !WebSocket. If it starts with HTTP protocol such as http: or https:, the stream performs HTTP streaming.

*options* - Configures the Stream connection.

 <b>alias</b> <font size="1">(added in 1.1)</font> - An alias of the url. When retrieving the stream instance by the url, you can use it instead of the lengthy url.

 <b>close</b> - A function or an array of functions to be called if the stream closes. Each function receives a event named {{{close}}} which is based on {{{jQuery.Event}}} and {{{CloseEvent}}} interface and the stream instance as the arguments.

 <b>context</b> - The value to be passed as {{{this}}} to the callback when the event is triggered.

 <b>converters</b> - A map of data-type/data-converter pairs. data-converter takes one argument which is a raw data and returns a transformed data. The default is {{{{text: window.String, json: $.parseJSON, xml: $.parseXML}}}}, {{{jQuery.parseJSON}}} is in 1.4.1 and {{{jQuery.parseXML}}} is in 1.5.

 <b>dataType</b> - The type of data that a server push to a client. The handled data is passed as the {{{data}}} attribute of message event. The supported types are {{{text}}}, {{{json}}} and {{{xml}}}. The default is {{{text}}} itself.

 <b>enableXDR</b> <font size="1">(added in 1.1.1)</font> - If set to {{{true}}}, XDomainRequest will be used as a transport when available.

 <b>error</b> - A function or an array of functions to be called if an error is detected. Each function receives a simple event named {{{error}}} which is based on {{{jQuery.Event}}} and the stream instance as the arguments.

 <b>global</b> <font size="1">(added in 1.1.1)</font> - Whether to trigger global Stream event handlers for this stream. The default is {{{true}}}.

 <b>message</b> - A function or an array of functions to be called if the stream receives a data. Each function receives a event named {{{message}}} which is based on {{{jQuery.Event}}} and {{{MessageEvent}}} interface and the stream instance as the arguments. The event has the data attribute which is sent by the server and is converted according to {{{dataType}}}.

 <b>open</b> - A function or an array of functions to be called if the stream opens. Each function receives a simple event named {{{open}}} which is based on {{{jQuery.Event}}} and the stream instance as the arguments.

 <b>openData</b> <font size="1">(added in 1.1.1)</font> - Additional parameters for open request. It is serialized to a query string and appended to the url.

 <b>protocols</b> <font size="1">(added in 1.1)</font> - An argument to be used to create !WebSocket instance.

 <b>reconnect</b> - Whether to automatically reconnect when connection closed. This is set to {{{true}}} by default for continuous stream.

 <b>rewriteURL</b> <font size="1">(added in 1.1.1)</font> - A function that can be used to modify url to contain a current user's session identifier when XDomainRequest is used as a transport. This is only effective when {{{enableXDR}}} options is true and XDomainRequest is available. It receives the original url and must return the modified url. The default function supports Java and PHP. For example, If a url is {{{echo?foo=bar}}} and JSESSIONID cookie exists, the url becomes {{{echo;jsessionid=${JSESSIONID}?foo=bar}}}, and if PHPSESSID cookie exists, the url becomes {{{echo?PHPSESSID=${PHPSESSID}&foo=bar}}}.

 <b>throbber</b> - Only for Webkit-based browsers such as Chrome and Safari. This option is to remove 'Throbber of doom' which is spinning loading indicator to show the user that a request is performing. The throbber doesn't be removed only when a Stream is created before all the requests such as image, script, iframe and ajax have finished loading, because a streaming connection is HTTP persistent connection. The following strategies are available:
  lazy - After the window's load event fires and some {{{delay}}}, it opens a Stream connection. The default setting for lazy is {{{{type: "lazy", delay: 50}}}} or simply {{{"lazy"}}}. It is suitable for typical use, unless the page contains many resources so the time taken for loading is very long. This is default.<br/>
  reconnect - Regardless of the window's load event, it opens a Stream connection immediately and closes it when the window's load event fires. Likewise after some {{{delay}}}, it opens a Stream connection again. The default setting for reconnect is {{{{type: "reconnect", delay: 50}}}} or simply {{{"reconnect"}}}. The request which opens a Stream is used twice, but you can provide seamless Stream for the user navigating pages.

 Since both of the above strategy use the window's load event handler, a logic creating a Stream (i.e {{{jQuery.stream("/stream")}}}) must not be located there in order to work this properly.
  * iOS Safari and Android Chrome are currently unsupported.
  * The load event of window doesn't consider ajax request, so when the event fires, incompleted Ajax request can get the throbber to keep spinning.

 <b>type</b> <font size="1">(added in 1.1)</font> - The type of stream. The default is {{{ws}}} when !WebSocket is available, {{{http}}} otherwise. If a scheme is specified in the url, the normalized scheme will be type value, ignoring a user-defined value.

<h3>Error and close event</h3>

Currently, the role of {{{error}}} event is ambiguous according to latest [http://dev.w3.org/html5/websockets/ W3C editor's draft] and [http://www.w3.org/TR/websockets/ W3C working draft] of The !WebSocket API specification. For the moment, I recommend {{{error}}} event handler set to the same handler of {{{close}}} event because they mean that whatever the reason the stream is closed.

*Example:* Stream wrapping a !WebSocket instance. If browser doesn't implement !WebSocket, nothing happens.
{{{
// Absolute path
$.stream("ws://example.com/stream", {});

// Relative path
$.stream("/stream", {type: "ws"});
}}}

*Example:* Stream performing HTTP Streaming.
{{{
// Absolute path
$.stream("http://example.com/stream", {});

// Relative path
$.stream("/stream", {type: "http"});
}}}

*Example:* The browser supporting !WebSocket will create !WebSocket instance whose url is {{{ws://example.com/stream}}}, and the others performs HTTP streaming on {{{http://example.com/stream}}}. 
{{{
$.stream("/stream", {});
}}}

*Example:* The browser supporting !WebSocket will create !WebSocket instance whose url is {{{ws://example.com/stream-websocket}}} and protocols is {{{chat}}}, and the others performs HTTP streaming on {{{http://example.com/stream-http}}}.
{{{
$.stream(window.WebSocket ? "/stream-websocket" : "/stream-http", {
    alias: "stream",
    protocols: "chat"
});
}}}

*Example:* Retrieving a stream.
{{{
$.stream("http://example.com/event-stream", {alias: "event", dataType: "json"});

// If that stream is the first stream in the document
$("#message-text").keyup(function(event) {
    if (event.which === 13) {
        $.stream().send({message: this.value});
    }
});

// Using url
$("#notice-button").click(function() {
    $.stream("http://example.com/event-stream").send({ts: new Date().getTime()});
    return false;
});

// Using alias
$("#close").click(function() {
    $.stream("event").close();
});
}}}

*Example:* Stream dispatching server-sent events into jQuery's event system.
{{{
$.stream("/event-stream", {
    dataType: "json",
    message: function(event) {
        $.event.trigger(event.data.name, event.data.data);
    }
});
}}}

*Example:* Adding custom converter
{{{
$.stream("/csv-stream", {
    dataType: "csv",
    converters: {
        "csv" : function(data) {
            return data.split(",");
        }
    }
});
}}}

*Example:* Introducing {{{this}}} to the callbacks.
{{{
$.stream("/notice", {
    dataType: "xml",
    context: $("#notice")[0],
    message: function(event, stream) {
        $("<p class='message'>" + event.data.message + "</p>").prependTo(this);
    }
});
}}}

*Example:* Disposable stream.
{{{
$.stream("/countdown.jsp", {
    reconnect: false,
    message: function(event, stream) {
        $("<p>" + event.data + " from " + stream.url + "</p>").appendTo("#panel");
    }
});
}}}

*Example:* Stopping the throbber using reconnect strategy with 100ms delay.
{{{
$.stream("/test.action", {
    throbber: {type: "reconnect", delay: 100}
});
}}}

*Example:* Stream with all callbacks.
{{{
$.stream("/chat", {
    dataType: "json",
    context: $("#content")[0],
    open: function(event, stream) {
        $("#editor").removeAttr("disabled").focus();
        stream.send({username: chat.username, message: "Hello"});
    },
    message: function(event, stream) {
        $("<p />").addClass("message").text(event.data.message).appendTo(this);
    },
    error: function() {
        $("#editor").attr("disabled", "disabled");
    },
    close: function() {
        $("#editor").attr("disabled", "disabled");
    }
});
}}}

*Example:* Suppressing global Stream events.
{{{
$.stream("/event", {
    global: false,
    message: function(event) {
        alert(event.data);
    }
});
}}}

*Example:* Additional parameters for open request.
{{{
$.stream("/stream", {
    openData: {
        type: "json",
        value: function() {
            return $("#value").val();
        }
    }
});
}}}

*Example:* Enabling XDomainRequest transport
{{{
$.stream("/stream", {
    enableXDR: true,
    rewriteURL: function(url) {
        var sessionId = "${pageContext.session.id}";
        return sessionId ? url.replace(/;jsessionid=[^\?]*|(\?)|$/, ";jsessionid=" + sessionId + "$1") : url;
    }
});
}}}

===jQuery.stream.version===
{{{String jQuery.stream.version}}}

Contains the version number of jQuery Stream.

===jQuery.stream.setup===
{{{Object jQuery.stream.setup(options)}}}

Sets default options.

*Example:* Automatically enabling XDomainRequest
{{{
$.stream.setup({enableXDR: true});
}}}
 
== jQuery.fn ==
Global Stream event handlers.

===.streamOpen(handler(event, streamEvent, stream))===
{{{jQuery .streamOpen(Function handler)}}}

Registers a handler to be called when the Stream has opend.

*Example:* Sending a message when Stream opens.
{{{
$(document).streamOpen(function(e, event, stream) {
    stream.send("Hello");
});
}}}

*Example:* Focusing the text input box when Stream opens.
{{{
$("#form :text").streamOpen(function() {
    $(this).focus();
});
}}}

===.streamMessage(handler(event, streamEvent, stream))===
{{{jQuery .streamMessage(Function handler)}}}

Registers a handler to be called when the Stream has received a message.

*Example:* Showing a server-sent message whenever Stream receives a message.
{{{
$("#messages").streamMessage(function(e, event) {
    $("<p />").addClass("message").html(event.data.message).appendTo(this);
});
}}}

===.streamError(handler(event, streamEvent, stream))===
{{{jQuery .streamError(Function handler)}}}

Registers a handler to be called when the Stream has detected a error.

*Example:* Displaying an alert dialog when Stream detects a error.
{{{
$(document).streamError(function() {
    alert("stream error!");
});
}}}

===.streamClose(handler(event, streamEvent, stream))===
{{{jQuery .streamClose(Function handler)}}}

Registers a handler to be called when the Stream has closed.

*Example:* Hiding the text input box when Stream whose url is '/test' closes.
{{{
$("#form :button").streamClose(function(e, event, stream) {
    if (stream.url === "/test") {
        $(this).prop("disabled", true);
    }
});
}}}

== Stream Object ==
Stream Object is the main agent that provides Comet Streaming using HTTP and !WebSocket protocol. It is based on [http://dev.w3.org/html5/websockets/ The WebSocket API] which is the ultimate solution to true two-way communication between a client and a server.

it doesn't rely on any specific server-side technology and third-party plugin-in such as ActiveX and Flash, so can be used with any server-side technology supporting asynchronous processing as long as the server meets the requirements. Form details about the requirements, see ServerSideProcessing.

As the Stream constructor is not exposed, use {{{jQuery.stream}}} instead.

Stream supports !WebSocket by simply wrapping its instance and HTTP Streaming by choosing proper transport according to browser and using it to communicate. The paragraphs below describe the streaming over HTTP in more detail.

<h3>The !WebSocket API where Stream Object bases</h3>

[http://www.w3.org/TR/2011/WD-websockets-20110419/ W3C Working Draft 19 April 2011]

<h3>Open</h3>

When the constructor is called, it sends a GET request which will be a one-way socket receiving a data from a server in real-time. Since the timestamp parameter ({{{_}}}) is always included in the request URL in order to prevent caching, the server doesn't need to configure it. Depending on the browser, the following transports are used to establish a stream connection.

*XMLHttpRequest* - For modern browsers except Internet Explorer. but in the case of Opera, it polls the response text manually using {{{setTimeout}}}.

*Hidden Iframe* - For Internet Explorer. It's different from the traditional way of fetching response. it polls the response text manually using {{{setTimeout}}} instead of requiring the server to print {{{<script>}}} tag. For this reason, the {{{Content-Type}}} of the response header must be set to 'text/plain', not 'text/html'.

*XDomainRequest* - Optionally available in Internet Explorer 8+. See [http://blogs.msdn.com/b/ieinternals/archive/2010/04/06/comet-streaming-in-internet-explorer-with-xmlhttprequest-and-xdomainrequest.aspx COMET Streaming in Internet Explorer] and [http://msdn.microsoft.com/en-us/library/cc288060%28VS.85%29.aspx XDomainRequest Object (MSDN)]. it requires padding to enable streaming and an {{{Access-Control-Allow-Origin}}} response header. For security reasons, XDomainRequest excludes cookies when sending a request, so in most cases session state is not maintained. Therefore, as of jQuery Stream 1.1.1, Hidden Iframe replaces XDomainRequest. Since the performance of XDomainRequest, of course, is far better than Hidden Iframe, it is recommended to use XDomainRequest if possible. The previous problem can be solved by rewriting url to contain the session id. How to rewrite url is depending on the server-side technology: For details, see [http://stackoverflow.com/questions/6453779/maintaining-session-by-rewriting-url my question] on stackoverflow.

The transport is chosen automatically according to the user's browser, and changing it is not allowed.

<h3>Sending data</h3>

Because HTTP Streaming is one-way, it simulates a way of transmitting data of full duplex socket like the !WebSocket by performing POST ajax request. The metadata is a series of the parameters starting with {{{metadata.}}} and included in request body to inform the server of additional data needed by server-side processing. So, following metadata entities are always added to request body.

*metadata.id* - stream identifier.

*metadata.type* - The purpose of request. In most cases, the value is {{{send}}} except a special case such as {{{close}}}.

<h3>Close</h3>

As mentioned above, because HTTP Streaming is one-way, streaming connection remains still open after aborting it in client-side. Therefore, when closing stream jQuery Stream sends a POST request whose metadata type is {{{close}}}.

===.url===
{{{String url}}}

The Stream URL.

===.options===
{{{Map options}}}

The Stream options.

===.readyState===
{{{Number readyState}}}

The state of the stream. It is the same as !WebSocket's readyState in terms of meaning.

*Example:* Checking the state of the stream.
{{{
$("#stream-state").click(function() {
    switch ($.stream().readyState) {
    case 0:
        alert("CONNECTING");
        break;
    case 1:
        alert("OPEN");
        break;
    case 2:
        alert("CLOSING");
        break;
    case 3:
        alert("CLOSED");
        break;
    }
});
}}}

===.send(data)===
{{{void .send(Object data)}}}

Transmits data through the stream.

*data* - The data to be sent to the server. If not already a string, it is converted to a query string by {{{jQuery.param}}}.

*Example: * Transmitting the mouse position.
{{{
$(document).click(function(event) {
    $.stream().send({x: event.pageX, y: event.pageY});
});
}}}

===.close()===
{{{void .close()}}}

Disconnects the stream.

*Example: * Closing the stream.
{{{
$("#close-stream").click(function() {
    $.stream().close();
});
}}}